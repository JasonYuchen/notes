# Serializability

[original post](https://jepsen.io/consistency/models/serializable)

参考严格串行化的说明，**串行化即去除时间约束的严格串行化**，因此例如进程A完成了写入x（注意写入不代表事务提交），而进程B才开始读取x，B依然不保证能够观测到A写入的x

- **串行化是一个事务模型 transactional model**
- **串行化也是一个多对象属性 multi-object property**
- **串行化无法完全可用 totally available**
  `TODO: why cannot`

由于串行化之要求所有事务的操作与某个串行执行事务的顺序一致，并**不要求发生顺序与事务真实顺序一致**，因此即使相同进程的顺序写入，较晚发生的事务也可以不观测到写入值（例如将该读取事务放在串行化顺序中早于写入事务的位置）

极端情况下一个系统**对所有单纯读取的事务都反回空，对所有单纯写入的事务都不生效，也可以认为是遵循了串行化模型**，通过安排所有读取事务在最初时刻发生则无法读取任何值、安排所有写入事务在最后时刻发生则写入无任何效果

需要特别注意的是数据库ACID中提到的**事务隔离级别可串行化 serializable，实际上更接近严格可串行化strict serializable**，Adya提出的可串行化隔离级别要求不允许出现：

- **脏写 dirty write**：`w1(x)...w2(x)`
- **脏读 dirty read**：`w1(x)...r2(x)`
- **不可重复读 non-repeatable read/fuzzy read**：`r1(x)...w2(x)`
- **幻读 phantom**：`r1(P)...w2(y in P)`，`P`代表一个谓词，即事务1读取了谓词`P`满足的数据，而随后事务2写入了同样满足的新数据`y`，显然事务1并没有读到这个晚加入的新数据

另一个角度上，Cerone提出可串行化包含三种属性：

- **内部一致性 internal consistency**：一个事务内部的读总是能读取到事务内最新的写入
- **外部一致性 external consistency**：一个事务内部的读取（如果该事务没有写入对应的数据）一定能够读取到前一个事务写入的数据，即前序事务的操作结果对后续事务可见
- **完全可见性 total visibility**：事务之间的可见关系是满足全序的

这两种规则都排除掉了一些定义上合法的可串行化历史，因此**数据库的可串行化隔离级别实际上与可串行化一致性并不相等**
