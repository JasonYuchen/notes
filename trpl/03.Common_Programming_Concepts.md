# Chapter 03. Common Programming Concepts

## 3.1 Variables and Mutability

é»˜è®¤æƒ…å†µä¸‹Rustä¸­æ‰€æœ‰å˜é‡éƒ½æ˜¯**ä¸å¯å˜çš„immutable**

```rust
let x = 5;
x = 6;  // cannot compile

let mut y = 5ï¼›
y = 6;  // fine
```

ä½¿ç”¨`const`å¯ä»¥å£°æ˜æ€»æ˜¯ä¸å¯å˜çš„å¸¸é‡

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Rustå…è®¸å˜é‡åé‡ç”¨ï¼Œä»è€Œæ¯å½“ä¸€ä¸ªå˜é‡åœ¨ä½¿ç”¨æ—¶å®é™…éƒ½æ˜¯æœ€è¿‘å£°æ˜çš„é‚£ä¸€ä¸ªå˜é‡ï¼Œå³æ©ç›–äº†å‰åºå˜é‡**shadowing**ï¼Œå¹¶ä¸”**é‡ç”¨ä¸è¦æ±‚ç±»å‹ç›¸åŒ**

```rust
let x = 5;
// now x = 5
let x = x + 1;
// now x = 6
{
    let x = x * 2;
    // now x = 12
}
// now x = 6
let x = "abc";
// now x = "abc"
```

## 3.2 Data Types

- **Scalar Types**
  - **Integer Types**
    - `i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize`
    - decimal: `98_222`
    - hex: `0xff`
    - octal: `0o77`
    - binary: `0b1111_0000`
    - byte: `b'A'`
    - è‹¥åœ¨debugæ¨¡å¼ä¸‹å‡ºç°æº¢å‡ºï¼Œåˆ™ä¼šåœ¨è¿è¡Œæ—¶panic
    - è‹¥åœ¨releaseæ¨¡å¼ä¸‹å‡ºç°æº¢å‡ºï¼Œåˆ™ä¼šæŒ‰ç…§è¡¥ç çš„è§„åˆ™ï¼ˆä¾‹å¦‚ç»™`u8`èµ‹å€¼256å®é™…ä¸Šæ˜¯0ï¼‰ï¼Œè™½ç„¶ä¸ä¼španicä½†æº¢å‡ºä¾ç„¶åº”è¯¥è¢«è§†ä½œæ˜¯ä¸€ä¸ªç¼–ç¨‹é”™è¯¯
    - åœ¨æœ‰å¯èƒ½ä¼šæº¢å‡ºçš„åœºæ™¯ï¼Œå¯ä»¥é‡‡ç”¨æ ‡å‡†åº“æä¾›çš„ä¸‹åˆ—å‡½æ•°æ¥**æ˜¾å¼å¤„ç†æº¢å‡º**ï¼š
      - `wrapping_*`: è¦æ±‚æ ¹æ®è¡¥ç çš„è§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚`wrapping_add`
      - `checked_*`: æº¢å‡ºæ—¶è¿”å›`None`
      - `overflowing_*`: è¿”å›ç»“æœå’Œä¸€ä¸ªæ ‡è®°è¡¨æ˜æ˜¯å¦å‘ç”Ÿäº†æº¢å‡º
      - `saturating_*`: æº¢å‡ºæ—¶ä¿ç•™è¯¥ç±»å‹çš„minimumæˆ–maximumå€¼
  - **Floating-Point Types**
    - `f32, f64`
    - éµå¾ªIEEE-754æ ‡å‡†
  - **Boolean Type**
    - `bool`: `true, false`
  - **Character Type**
    Rustçš„å­—ç¬¦ä¸²ä»¥UTF-8ç¼–ç ï¼Œå…¶å­—ç¬¦ç±»å‹å®é™…ä¸Šé‡‡ç”¨4å­—èŠ‚å­˜å‚¨å¹¶ä¸”è¡¨è¾¾å•ä¸ªUTF-8å­—ç¬¦ï¼Œä¾‹å¦‚`let c = 'ğŸ˜»'`
- **Compound Types**
  - **Tuple Type**
    - `let tup: (i32, f64, u8) = (500, 6.4, 1);`: tupleå¯ä»¥åŒ…å«å¤šä¸ªä¸åŒç±»å‹
    - `let (x, y, z) = tup;`: ç±»ä¼¼c++çš„ç»“æ„åŒ–ç»‘å®š
    - `let five = tup.0;`: é‡‡ç”¨ä»0å¼€å§‹çš„ä¸‹è¡¨å¯ä»¥æŒ‰é¡ºåºè®¿é—®tupleçš„å…ƒç´ 
    - tupleä¸€æ—¦ç¡®å®šå°±æ— æ³•æ”¹å˜å¤§å°ï¼Œé•¿åº¦å›ºå®š
  - **Array Type**
    - `let a = [1, 2, 3, 4, 5];`
    - `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    - `let a = [3; 5];`: ç”Ÿæˆé•¿åº¦ä¸º5ä¸”æ¯ä¸ªå…ƒç´ éƒ½æ˜¯3çš„æ•°ç»„
    - **è¶Šç•Œè®¿é—®æ•°ç»„å…ƒç´ ä¼šç›´æ¥å¯¼è‡´panic**

## 3.3 Functions

Rusté‡‡ç”¨å°¾ç½®ç±»å‹ï¼š

```rust
fn plus_one(x: i32) -> i32 {
  x + 1 // or "return x + 1;"
}
```

## 3.4 Comments

Rustçš„æ™®é€šæ³¨é‡Šå‡é‡‡ç”¨æ¯è¡Œå¼€å¤´`//`æ¥æ ‡è®°

## 3.5 Control Flow

- `if`

  ```rust
  if number < 5 {
    println!("true");
  } else if number == 5 {
    println!("false");
  } else number > 5 {
    println!("ok");
  }

  let number = if ok { 5 } else { 6 };
  ```

- `loop`
  
  ```rust
  loop {
    println!("again");
    cnt -= 1;
    if cnt == 0 {
      break;
    }
  }
  ```
  
  å¯¹äº**åµŒå¥—çš„å¤šå±‚å¾ªç¯ï¼Œå¯ä»¥é‡‡ç”¨æ ‡ç­¾æ ‡è®°æ¯ä¸€å±‚å¾ªç¯**ï¼Œä¸å¸¦æ ‡è®°çš„`continue`å’Œ`break`é»˜è®¤ä½œç”¨ä¸æœ€è¿‘çš„ä¸€å±‚å¾ªç¯ï¼Œè€Œé‡‡ç”¨æ ‡è®°å¯ä»¥ç›´æ¥ä½œç”¨äºç›¸åº”å±‚çš„å¾ªç¯
  
  ```rust
  // use loop label to handle nested loop
  'counting_up: loop {
    loop {
      if x == 0 {
        break;
      }
      if y == 0 {
        break 'couting_up;
      }
    }
  }
  ```

  åˆ©ç”¨`break`è¡¨è¾¾å¼å¯ä»¥ç›´æ¥ä»å¾ªç¯ä¸­è¿”å›å€¼

  ```rust
  let result = loop {
    counter += 1;
    if counter == 10 {
      break counter * 2;
    }
  }
  ```

- `while`

  ```rust
  while number != 0 {
    number -= 1;
  }
  ```

- `for in`å¾ªç¯éå†å®¹å™¨å…ƒç´ 

  ```rust
  let a = [10, 20, 30, 40, 50];
  for x in a {
    println!("value is {}", x);
  }

  for x in (1..4).rev() {
    println!("{}", x);  // 3 2 1
  }
  ```
