# Chapter 15. Smart Pointers

## 15.1 Using `Box<T>` to Point to Data on the Heap

`Box<T>`相当于C++中的`unique_ptr<T>`，指向堆上分配的数据，并且在离开作用域时会自动释放资源：

```rust
let b = Box::new(5);    // Box<i32>
println!("b = {}", b);  // b = 5
```

采用`Box<T>`实现类似链表的数据结构：

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

`Box<T>`实现了`Deref` trait因此可以直接视为`T`使用会被自动解引用，实现了`Drop` trait因此在离开作用域时就会执行释放资源的操作

## 15.2 Treating Smart Pointers Like Regular References with the `Deref` Trait

```rust
let x = 5;
let y = &x;
let z = Box::new(x);

assert_eq!(5, x);
assert_eq!(5, *y);
assert_eq!(5, *z);
```

**通过实现`Deref` trait可以将一个类型以引用的方式使用**，例如使用解引用`*`操作符：

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    // associated type
    type Target = T;

    fn deref(&self) -> &Self::Target {
        // chapter 5, use `.0` to access the first element of a tuple
        &self.0
    }
}
```

从而对于自定义的类型我们也可以这样使用解引用，另外需要注意的是，**解引用只会发生一次，不会递归**：

```rust
let x = 5;
let y = MyBox::new(x);

assert_eq!(5, x);
// ok now, *y is equivalent to *(y.deref())
assert_eq!(5, *y);
```

另外在**函数和方法使用时，不需要显式的使用解引用操作符**，Rust通过**Deref Coercion**自动完成，从而更为便利，每当类型定义了`deref`后（即实现了`Deref` trait），Rust都会调用足够多的`deref()`次数使得参数匹配函数或方法的签名，并且这些都仅仅是编译时的开销：

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    // with Deref Coercion
    // &m is &MyBox<String>
    // Rust called deref() and it is then converted to &String
    // the standard library provide the String's deref() which returns &str so
    // Rust called deref() and it is then converted to &str
    hello(&m);
    // without Deref Coercion
    // manually call *m to get String,
    // then use &(*m)[..] to get &str
    hello(&(*m)[..]);
}
```

注意：对于可变引用来说，需要实现`DerefMut` trait，Rust实际上执行的Deref Coercion在考虑可变性时实际上是如下的规则，**可变可以转为不可变**，但反之不可，从而保证了安全（类似C++中的`const &`可以接受`const`和non-`const`的对象，但`&`不能接受`const`的对象）：

- `&T` -> `&U` when `T: Deref<Target=U>`
- `&mut T` -> `&mut U` when `T: DerefMut<Target=U>`
- `&mut T` -> `&U` when `T: Deref<Target=U>`

## 15.3 Running Code on Cleanup with the `Drop` Trait

参考C++中的析构函数和RAII概念，通过**实现`Drop` trait可以自定义在对象离开作用域时自动执行一段代码**，可以用于资源释放等操作

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
// CustomSmartPointers created.
// Dropping CustomSmartPointer with data `other stuff`!
// Dropping CustomSmartPointer with data `my stuff`!
```

需要注意，**手动调用`.drop()`无法通过编译**，因为在离开作用域时编译器依然会插入`.drop()`导致出现double free问题，当有需要时可以通过标准库提供的`std::mem::drop`函数来显式`drop(obj)`，实际上该函数就是接受了传入参数的所有权，并且该函数什么也不执行，从而只会触发一次对象的析构

> `pub fn drop<T>(_x: T) { }`
> Because `_x` is moved into the function, it is automatically dropped before the function returns.

## 15.4 `Rc<T>`, the Reference Counted Smart Pointer

## 15.5 `RefCell<T>` and the Interior Mutability Pattern

## 15.6 Reference Cycles Can Leak Memory
