# Knapsack Problem

[WIKI](https://en.wikipedia.org/wiki/Knapsack_problem)

[背包问题九讲](https://github.com/tianyicui/pack/blob/master/V2.pdf)

给定一组物品 $i = 1, 2, ... N$，每个物品都有相应的重量 $w_i$ 和价值 $v_i$，在限定的总重量 $W$ 内，如何选择物品使得总价值最大，即：

```math
maximize\ \sum_{i=1}^{N}{v_i x_i} \\
subject\ to\ \sum_{i=1}^{N}{w_i x_i \leq W}
```

采用暴力枚举的方式，则每个物品（假如是0-1背包问题）有选与不选两种状态，则最终时间复杂度可以高达 $O(2^N)$，采用动态规划的方式可以将复杂度降低到 $O(NM)$，其思想如下：

定义`dp[i][j]`为在前`i`件物品中选择重量不超过的`j`的组合且价值最大化时的价值，显然`0<=i<=N`且`0<=j<=W`

## 0-1

0-1背包问题下，**每个物品可选择0次或1次**，即上述条件中的 $x_i \in \{0, 1\}$，那么当每次加入新的一件物品来选择，则到第`i`件物品时，其不同重量限制下最大可装价值就是以下两种情况的更大者：

1. 不选择该第`i`件物品，从而其最大价值与没有遇到第`i`件物品时是一样的，因此`dp[i][j] = dp[i-1][j]`
2. 选择第`i`件物品（需要满足目标重量`j`能够放得下该物品，即`j >= w[i]`），从而其最大价值就是没有遇到第`i`件物品时的结果，加上该第`i`件物品，因此`dp[i][j] = dp[i-1][j-w[i]]+v[i]`

选择这两个情况中能有更大价值的情况，因此最终0-1背包问题的状态转移方程可以表达为

```cpp
dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);  // j >= w[i]
```

容易确定的起始条件就是在不选择任何物品时价值为零，即`dp[0][j] = 0`

从计算方式中可以看出，`dp[i][j]`仅与`dp[i-1][0,...,j-1]`有关（显然`w[i]>0`），因此可以**对`j`从大到小遍历**，避免覆盖并重用，仅使用一个`dp[]`向量，**空间优化**基本流程如下：

```cpp
dp[0,...,W] = 0;
for i = 1,...,N:
  for j = W,...,w[i]: // W->0
    dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
```

## Unbounded

无限/完全背包问题下，**每个物品可选择0次或任意次**，即上述条件中的 $x_i \geq 0$，那么当每次加入新的一件物品来选择，则到第`i`件物品时，其不同重量限制下最大可装价值就是以下两种情况的更大者：

1. 不选择该第`i`件物品，从而其最大价值与没有遇到第`i`件物品时是一样的，因此`dp[i][j] = dp[i-1][j]`
2. 选择第`i`件物品（需要满足目标重量`j`能够放得下该物品，即`j >= w[i]`），从而其最大价值就是遇到第`i`件物品时的结果，需要**注意此时上一个状态依然是`i`因为可以反复拿**，因此`dp[i][j] = dp[i][j-w[i]]+v[i]`

```cpp
dp[i][j] = max(dp[i-1][j], dp[i][j - w[i]] + v[i]);  // j >= w[i]
```

**注意由于其反复拿第`i`件物品的特性，因此必须对`j`从小到大遍历**

```cpp
dp[0,...,W] = 0;
for i = 1,...,N:
  for j = w[i],...,W: // 0->W
    dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
```

## Bounded

有限/多重背包问题下，**每个物品可选择不超过给定次数** $c$，即上述条件中的 $x_i \leq c_i$，那么当每次加入新的一件物品来选择，则到第`i`件物品时，其不同重量限制下最大可装价值就是以下两种情况的更大者：

1. 不选择该第`i`件物品，从而其最大价值与没有遇到第`i`件物品时是一样的，因此`dp[i][j] = dp[i-1][j]`
2. 选择第`i`件物品`k`次（需要满足目标重量`j`能够放得下该物品，即`k <= min(c[i], j/w[i])`），因此`dp[i][j] = max(dp[i-1][j-k*w[i]]+k*v[i])`

```cpp
dp[0,...,W] = 0;
for i = 1,...,N:
  for j = W,...,w[i]: // W->0
    for k = 0,1,...,min(c[i], j/w[i]):
      dp[j] = max(dp[j], dp[j - k*w[i]] + k*v[i])
```

## 恰好装满

常规的背包问题通常初始化都是`dp[0][0,...,W] = 0`，而在恰好装满的要求下，由于**非满的情况是不可行的因此应该被初始化为`-inf`，而只有`dp[0,...,N][0] = 0`即重量为零的价值为0**

[139. Word Break](https://leetcode.com/problems/word-break/)

[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)

[322. Coin Change](https://leetcode.com/problems/coin-change/)

[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

## 方案总数

给定价值情况下希望求出满足（价值大于等于给定值）的方案总数，此时简单的将前述**状态转移方程的`max`替换为`sum`即可，即累计所有可能性**

[494. Target Sum](https://leetcode.com/problems/target-sum/)

## 多维背包

问题求解存在多个约束条件，例如重量不超过`W`且体积不超过`V`，需要满足多个约束条件的背包问题称为多维背包问题，这种问题求解**需要`dp[i][j][k]...`多个维度，实际求解过程与传统的背包问题一致，只是需要每个维度都有相应的计算方式**，例如`dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-w[i]][k-v[i]] + v[i]`

[474. Ones and Zeros](https://leetcode.com/problems/ones-and-zeroes/)

## 最优方案

在获得最高价值时希望获取相对应的物品选择方案，通常需要记录每个`dp[i][]`值是由哪个前值计算出来的，形成类似链表的结果，通过最终值逐级反推就可以获得完整的结果（类似最短路径中的节点记录方式）

以0-1背包问题为例，显然从最终结果`dp[i][j]`反推，若`dp[i][j] == dp[i-1][j]`就说明未选择第`i`项，反之选择了第`i`项
