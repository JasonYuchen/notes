# C++ Coroutines: Theory

[original post](https://lewissbaker.github.io/2017/09/25/coroutine-theory)

## 常规函数 "Normal" Functions

- **激活帧 Activation Frames**
    激活帧就是一块内存包含了函数调用时的当前状态，包括传递的参数和所有局部变量，对于常规函数还包括了返回的地址，因此**整个激活帧也可以被认为是一个continuation**，常规函数的激活帧有严格的生命期，通常也叫栈Stack，分配在栈上的激活帧叫做栈帧Stack Frame
- "Call"
    分配激活帧，传递参数，写入返回的地址resumption-point
- "Return"
    储存返回结果，激活帧被销毁：销毁所有局部变量、参数对象、激活帧自身占用的内存，随后根据resumption-point恢复调用者的栈帧并传递控制权给调用者

## 协程 Coroutines

协程将常规函数的Call和Return进一步划分为了**Suspend, Resume和Destroy三部分**

- **协程激活帧 Coroutine activation frames**
    通常由于协程可以在不摧毁激活帧的情况下suspend或者resume，因此生命期无法保证，所以**协程帧往往需要分配在堆上**，除了部分情况下编译器能够确保生命期，并且协程中使用的变量也会有一部分是仅在当前作用域而可以安全摧毁的，因此**协程激活帧可以认为由coroutine frame和stack frame两部分组成**
- **"Suspend"**
    Suspend允许协程在执行到暂停点suspend-points时将控制流交给resumer或是返回给caller，C++20指定的暂停点用`co_await,co_yield`关键字来标识
    当执行到暂停点时，协程需要确保所有寄存器registers值都写入协程帧、将当前暂停点位置写入协程帧来确保后续协程的恢复或销毁能正确的处理对象
    在C++20中，协程准备好被挂起后，在控制流给caller/resumer前还可以额外执行一段逻辑（自定义），见[`co_await`](Cppcoro_Understanding_co_await.md)，可以用于直接恢复resume协程、或是将协程栈的控制权handle给其他线程或对象，**通过coroutine-frame handle的方法可以直接resume/destroy对应的挂起的协程**
- **"Resume"**
    Resume操作可以对一个挂起的协程执行，即从暂停的位置恢复现场继续执行，通过corooutine-frame handle的`resume()`实现，当恢复之后继续允许到下一个暂停点或是完整运行结束时就会返回到调用`resume()`的位置
- **"Destroy"**
    Destroy操作可以对一个挂起的协程执行，即不再继续执行，直接销毁coroutine-frame的所有资源，通过coroutine-frame的`destroy()`实现
- **协程的"Call"**
    协程的Call基本和常规函数一致，但是常规函数在运行完成才会返回，而**协程的Call可以在到达一个暂停点后就返回**，调用协程函数时，caller分配栈帧写入参数和返回地址，随后交给协程函数（和调用常规函数一致），**随后协程分配协程帧，将变量copy/move到协程帧从而可以使得变量与协程帧有一样的生命周期**
- **协程的"Return"**
    当协程执行到`co_return`时，首先存储返回的结果，摧毁局部变量（不包括协程参数），随后在控制流给caller/resumer之前还可以额外执行一段逻辑（自定义），可以用于resume其他协程、或是将返回结果发布，**协程最后可以继续suspend（保持coroutine-frame）也可以destroy（摧毁coroutine-frame），控制流传递给caller/resumer（suspend/resume）**

## 协程示例 An Illustration

假定有一个函数`f()`（normal/coroutine），会调用一个协程`x(int a)`（coroutine），在调用到`f()`时状态如下：

```text
STACK                     REGISTERS               HEAP

                          +------+
+---------------+ <------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
```

进入`f()`内调用`x(42)`，从而写入返回地址`ret=...`、参数`a=42`，栈指针寄存器`rsp`始终指向栈顶

```text
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
```

由于`x(int a)`是协程，由编译器调用`operator new`分配一块堆上的协程帧，并且将参数`a=42`拷贝进协程帧，协程帧指针通常会存放在另一个寄存器中，例如`rbp`

```text
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
```

此时`x(42)`内又进一步调用了一个常规函数`g()`，与调用`f()`时相同

```text
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
```

当常规函数`g()`返回时，假设返回了对象`b=789`，由于上层`x(int a)`是协程，因此`b`也会被储存在协程帧中

```text
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
```

假定此时`x(42)`执行到了某个暂停点suspend-point，并且没有摧毁协程帧而返回到了`f()`，则协程`x(42)`的栈帧部分被摧毁，协程帧部分保留，并被`handle`控制，且协程帧中会进一步保存`x(42)`暂停点的位置`RP=x()+99`以备未来通过`handle.resume()`恢复执行

```text
STACK                     REGISTERS               HEAP
                                        +----> +-----------+
                          +------+      |      |  x()      |
+----------------+ <----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
```

随后`f()`继续正常执行，直到某一刻调用了`handle.resume()`（可以在`f()`内，可以在另一个函数甚至另一个线程，只要一直持有`handle`）就会直接从`RP=x()+99`从上次`x(42)`暂停的位置直接继续执行

在另一个线程内调用`handle.resume()`也可以恢复协程运行，因此在使用协程时，要**注意`thread_local`在同一协程内每次执行的值未必相同（[如果协程在不同的线程上执行](https://github.com/GorNishanov/coroutines-ts/issues/2#issuecomment-229409157)）**

```text
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |                   +-->  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
```
