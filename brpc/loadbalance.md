# 负载均衡 Load Balance

## 随机 Random

## 轮转 Round-Robin (RR)

## 局部感知 Locality-Aware Load Balancing (LALB)

### 1. 原理 Principle

负载权重由以下公式定义：

```text
Weight = QPS / Latency
```

一种分析方法如下：

- **稳定状态时的QPS显然和其分流权值W成正比**，即`W1 / W2 ≈ QPS1 / QPS2`
- 根据分流公式又有`W1 / W2 = QPS1 / QPS2 * (L2 / L1)`

故稳定状态时L1和L2应当是趋同的，即当L1小于L2时，节点1会更获得相比其QPS1更大的W1，从而在未来获得更多的流量，直到**其延时高于平均值或没有更多的流量**

另一方面，这种基于QPS和Latency的负载均衡算法要求：

- **对吞吐QPS和延时Latency的统计都需要统计窗口**，窗口越大数据越可信，噪声越少，但反应也慢了，一个异常的请求可能对统计值造不成什么影响，等我们看到统计值有显著变化时可能已经太晚了
- 只统计已经响应的请求不够，**还需要考虑正在处理的请求**，否则我们可能会向一个已经出问题的节点（请求不响应）继续发送请求
- 多线程下，节点列表可能出现改变，即**非静态**
- 权重查询高效

### 2. 双重缓冲 DoublyBufferedData

基本工作原理：

- 数据分为**前后台`T data[2]`**，前台由Reader读取，每个**Reader都有一个thread_local锁**，这样所有Reader相互不会阻塞，前后台由`atomic_int index`的值0或1来决定
- Reader每次拿到锁，执行读取逻辑后立即释放锁
- 只有**一个后台Writer，直接修改后台数据**，切换前后台(修改`atomic_int index`)，**依次获得所有Reader的锁并立即释放**
- 当Reader正在读时，其锁阻止Writer的获取锁，从而一直在读原前台数据，大部分情况下Reader都不需要竞争来获得锁，性能高
- Writer修改完数据后依次获得Reader的**锁并立刻释放是为了确保Reader当前的Read都结束并且后续都只会处理新前台(只会见到新的`index`)**，那么Writer可以安全修改旧前台/新后台
- index本身是atomic_int，读取时使用memory_order_acquire，写入时使用memory_order_release，从而**确保多线程可见性**

### 3. 权重树 WeightTree

由于LALB按权值进行分流，因此朴素的分流过程就是首先获得所有权值和`Total`，每次随机产生一个`[0, Total-1]`的的随机数R，再进行一次遍历直到当前权值和`Total'<=R`而再加一项权值就会`Ttotal'>R`，此时开始分流；由于R是`[0, Total-1]`的均匀分布，因此这一随机产生R并根据R分流，最终可以达成按权值分流，但是O(N)的性能过低，更好的方法是采用**权重树O(logN)**

`TODO: weight tree`

### 4. 基本权重 Base weight

除了待删除的节点，所有**节点的权重都大于0**，这是因为如果某个节点缓慢所以权值为0，那么后续所有请求都不会分流到这个节点，从而这个节点即使变快了也不能被感知到

而这同样创造了另一个问题就是间断性总会有一些流量发送给全职很低响应很慢的服务器而一定会超时，实际情况中往往问题不大，由于持续的资源监控，不太会出现服务持续非常缓慢的情况，可以参考的解决方案有：

- 对于**权值低的服务器强制发送备份请求backup request**
- 保存一些曾经发向缓慢服务器的请求作为探测probe，这样就不会浪费新的请求（实现较复杂）

### 5. 未响应请求的延迟 Inflight delay

**还未响应的请求的延迟也必须得到监控**，否则等到了超时或错误（往往数倍正常响应时间）时才有机会更新权值，而在这个过程中可能由于分流导致浪费了大量请求，统计请求的耗时：

- 选择服务器时累计发出时间和待响应次数
- 反馈权值时扣除发出时间和待响应次数

待响应请求的平均耗时就是`inflight delay = sum(current time - request time) / inflight count`，那么当`inflight delay > average latency`时就可以对目标服务器进行权值惩罚，例如一个线性惩罚方式`weight = base weight * average latency / inflight delay`，同时由于响应时间往往是围绕平均延时的一个正太分布，可以引入标准差作为一个bound允许一定的延时波动而不更新权值，例如`inflight delay > average latency + max(bound * 3, MIN_BOUND)`就进行惩罚，系数`3`是正态分布中的经验值

### 评论 Comment

请求与响应以及按权值分流，可以看作对目标服务器的负反馈闭环控制，因此控制理论中例如PID控制器可以作为参考
