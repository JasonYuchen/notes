# Chapter 7. Transactions

![cover](images/c7.png)

## 事务概念 The Slippery Concept of a Transaction

1. ACID的含义 The Meaning of ACID
   事实上ACID的意义是非常模糊的，很多宣称支持ACID的数据库实际上提供的保证各不相同
   - **原子性 Atomicity**
     要么都做，要么都不做，即事务中途失败需要把已经做的修改回滚撤销掉
   - **一致性 Consistency**
     要求数据库保持一致性，即例如一个事务开始时数据库某些约束是满足的，事务结束时这些约束依然满足，但事实上除了外键约束等数据库自身的约束，例如A+B=C这种约束是由应用程序来保证的，数据库只负责存取数据，因此**一致性并不应该是数据库的属性**
   - **隔离性 Isolation**
     多个并发事务之间相互隔离，类似于并发场景下的竞争问题，一个事务做了各种修改之后，另外的事务要么看到提交后的所有修改，要么什么也看不到
   - **持久性 Durability**
     数据能够持久存储而不会丢失，一般来说就是事务一旦提交，数据就落盘存储不会丢失，事实上极端场景下数据无法满足持久性，随着分布式系统的兴起，持久化除了**可以落盘实现，也可以通过副本实现**，只要始终有一个完整的副本，也可以视为持久性
2. 单对象和多对象操作 Single-Object and Multi-Object Operations
   - 单对象写 Single-object writes
     **Atomicity可以通过写日志**来实现，**Isolation可以通过对象加锁**实现，但是事务往往操作多个对象，执行多个操作
   - 多对象事务的需求 The need for multi-object transactions
   - **错误处理与终止 Handling errors and aborts**
     事务的核心特点有一旦失败就会回滚，因此应用程序可以安全重试（无主复制leaderless replication系统只提供尽我所能保证，应用程序需要自己处理半完成的情况），但是**重试一个终止的事务虽然简单高效，也存在缺陷**：
     - 如果事务实际上成功了，但在告知应用层时出现了网络等原因，导致了应用重试了一个成功的事务，则需要内部去重机制，也即**幂等性idempotence的保证**
     - 如果事务由于负载过大失败，则重试会加重服务器过载，导致**雪崩**，可以考虑**指数回退exponential backoff算法重试**
     - 只有暂时性错误重试才有意义，例如暂时网络中断、正在故障转移等，对于**永久性错误重试无意义**
     - 如果事务对于数据库以外的部分都有副作用，而数据库回滚只是数据库内的，则真正的事务原子性并没有得到保证，对于**跨系统的事务可以考虑二阶段提交two-phase commit协议**来解决
     - 如果客户端本身在重试时崩溃，则数据也全都丢失了

## 弱的隔离级别 Weak Isolation Levels

可串行化的隔离级别（一系列并发的事务其处理结果可以序列化成顺序执行的事务的处理结果）代价过高，大部分系统一般都是提供更弱的隔离级别，例如：

1. **读已提交 Read Committed**
    最基本的隔离级别就是读已提交，保证读数据时只有提交的事务数据才会被看到，**没有脏读dirty reads**；保证写数据时只有提交的事务数据才有可能被覆盖，不会覆盖还未提交的数据，**没有脏写dirty writes**
    注意，**读已提交并不保证不丢失数据**，例如并发递增（依赖旧值），则读已提交依然会导致丢失值
    - 没有脏读 No dirty reads
      ![7.1](images/7.1.png)
    - 没有脏写 No dirty writes
      ![7.2](images/7.2.png)
    - 实现读已提交 Implementing read committed
      使用**行级锁row-level locks来避免脏写**，一个已经事务持有行级锁再进行修改，则提交前锁没有被释放，其他事务只能等待；但是不用锁来避免脏读（性能损失太大），而是通过**保存旧值和每个事务自己正在使用的新值来避免脏读**，则并发事务都首先获得当前旧值，这样就不会读取到其他进行中事务未提交的值
2. **快照隔离和可重复读 Snapshot Isolation and Repeatable Read**
    读已提交还存在其他问题，例如Alice两次读到到的数额加起来发现少了100，出现了数据不一致，如果此时再读一次数据就一致了，这种现象称为**不可重复读nonrepeatable read或读偏差read skew**
    ![7.3](images/7.3.png)
    在部分场景下这是可以接受的，但是涉及到例如备份backups（备份需要如此读所有数据，则出现这种情况时偏差值被备份了，并在恢复时会导致数据库数据不一致）或分析型查询（检查数据一致性，出现偏差时就会失败）时就不可接受了
    - 快照隔离要求每个事务**始终只会看到事务开始时的数据**，即使后续其他事务修改了数据也不可见，即类似给数据库打了快照，在快照上执行事务
    - **实现快照隔离**
      - 使用**锁来避免脏写**，由此多个写事务需要等待，但是读事务可以并发且不需要锁，因此**写并不阻塞读，读也并不阻塞写**；数据库需要保存一个数据的多个提交版本，这种方式也叫**多版本并发控制MVCC, multiversion concurrency control**
      - 在每个事务开始时获得一个递增的**transaction id, TID**，写入任何数据时数据都带上对应事务的TID，每行都有`created_by=TID, deleted_by=TID`，访问时每个事务的可见性规则见下述
      - 定期删除不会再被任何事务访问到（所有**进行中事务TID均大于`deleted_by=TID`**参考可见性规则）的且被标记为deleted的数据
      - `update`被处理成`delete+insert`
    - **快照隔离的可见性规则 Visibility rules for observing a consistent snapshot**
      - 每个事务开始时，数据库列出所有活跃的进行中事务，这些事务的修改无论是否commit，都被忽略
      - 任意在此事务之后开始的新事务的任意修改无论是否commit，都被忽略
      - 所有终止的事务的任何修改，都被忽略
      - 其他所有修改都可见

      换言之只要满足以下情况就可见

      - 每个事务开始时，**`created_by=TID`事务已经commit则可见**
      - 对象**没有`deleted_by`，或者`deleted_by=TID`事务还未commit则可见**

      ![7.4](images/7.4.png)

    - 索引和快照隔离 Indexes and snapshot isolation
      **索引指向所有快照**，快照有更新时就更新索引，或者对B-trees进行copy-on-write
    - 可重复读和命名混淆 Repeatable read and naming confusion
      快照隔离被广泛使用，但是在不同的系统中给其定了不同的名字，Oracle称之为可串行化，PostgreSQL/MySQL称之为可重复读

3. **避免更新丢失 Preventing Lost Updates**
    在涉及read-modify-write时可能会出现更新丢失，当多个事务**并发对同一个数据read-modify-write时，就可能会出现更新丢失**，事实上先读，基于读做增量修改，再写回非常常见，因此也有一系列方法来解决：
    - **原子写操作 Atomic write operations**
      原子写确保对对象的修改是并发安全的，底层往往通过**对修改对象加锁**来实现，由此对于多副本的情况，也有分布式锁的概念
    - **显式加锁 Explicit locking**
      当原子写操作不足以支持安全时，可以通过显式加互斥锁，例如使用`for update`语句显式要求数据库加锁

      ```SQL
      SELECT * FROM figures
        WHERE name = 'robot' AND game_id = 222
        FOR UPDATE;
      -- Check whether move is valid, then update the position
      -- of the piece that was returned by the previous SELECT
      UPDATE figures SET position = 'c4' WHERE id = 1234；
      COMMIT;
      ```

    - 自动检测更新丢失 Automatically detecting lost updates
      允许操作并发执行，但是**由事务管理器来检测是否有丢失的更新**，如果有则主动中止一些事务并发起重试，检测丢失的更新可以和快照隔离搭配实现
    - CAS修改, Compare-and-set
      类似原子写操作
    - **冲突解决和副本 Conflict resolution and replication**
      由于多副本的数据库，每个副本可能被单独修改，因此检测同一数据在多个副本上的并发安全要求额外的工作，同时由于**显式加锁和CAS都假定一个对象**，因此对于无主leaderless和多主multileader复制不适用，参考[检测并发写入](https://github.com/JasonYuchen/notes/blob/master/ddia/05.Replication.md#4-%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%8F%91%E5%86%99%E5%85%A5-detecting-concurrent-writes)，允许并发修改，但是通过**维护不同版本**的值（版本号），由应用程序来解决冲突

4. **写入偏差Write Skew**
    例如要确保至少有1人，但是2人并发提出请假，在快照隔离的作用下，2人分别请假的事务都提交成功了，结果反而最后1人都没有了；可以通过对`currently_on_call`的查询**显式加互斥锁`for update`，由此将两个单独的事务串行**，不同时发生，这种并发写入也叫写入偏差
    ![7.5](images/7.5.png)

    ```SQL
    BEGIN TRANSACTION;
    SELECT * FROM doctors
      WHERE on_call = true
      AND shift_id = 1234 FOR UPDATE;
    ```

5. **幻读 Phantoms**
    幻读的定义是事务在执行连续的读取时，由于**并发事务的插入和删除记录**导致了连续的读取返回了幽灵值

    **快照隔离确保了只读查询不会出现幻读**，但是依然无法避免自身对数据修改，最后多个并发事务提交的结果合并时出现约束被打破，而**读已提交则无法避免幻读**
6. **物化冲突 Materializing conflicts**
    上述的例子要求`SELECT count(*)... >1`，由于这个限制并不是一个实际存在的对象，不能显式加锁，最后通过对相关的行加锁`for update`来解决；由此可以通过把这个`count(*)`作为一个对象，此时即引入了**物化视图Materialized view**，但物化冲突难以使用，应避免

## 可串行化 Serializability

1. **实际的串行执行 Actual Serial Execution**
2. **两阶段锁 Two-Phase Locking, 2PL**
3. **串行化快照隔离 Serializable Snapshot Isolation, SSI**
