# Pitfalls when using Coroutine Lambda

[original discussion](https://groups.google.com/g/seastar-dev/c/RFGF_a81lG4)

## A Weird `use-after-free`

The following code will cause `user-after-free` if we do not explicitly copy the `updates` that will be freed before the resolution of the whole lambda in `with_lock` (the `save` function will be `co_await`ed in caller side), why?

```cpp
future<> segment_manager::save(std::span<update_pack> updates) {
  return with_lock(_mtx, [=]() -> future<> {
    // will segfault (use-after-free) if remove this explicit copy
    std::span<update_pack> ups = updates;
    bool need_sync = false;
    for (const auto& up : ups) {
      bool sync = co_await append(up.update);
      need_sync = need_sync || sync;
    }
    if (need_sync) {
      co_await sync();
    }
    for (auto& up : ups) {
      up.done.set_value();
    }
  });
}
```

## How Lambdas Are Translated

[Lambda](https://en.cppreference.com/w/cpp/language/lambda) is just yet another syntax sugar introduced in C++11. A simple lambda will be translated into the following code (generated by [cpp insights](https://cppinsights.io)):

```cpp
int main() {
  int num_1 = 0;
  auto f = [&num_1](int num_2) {
    return num_1 + num_2;
  };
  return f(0);
}
```

The lambda will be reconstructed as an anonymous class with captures and `operator()`:

```cpp
int main()
{
  int num_1 = 0;
    
  class __lambda_5_14
  {
    public: 
    inline /*constexpr */ int operator()(int num_2) const
    {
      return num_1 + num_2;
    }
    
    private: 
    int & num_1;
    
    public:
    __lambda_5_14(int & _num_1)
    : num_1{_num_1}
    {}
    
  };
  
  __lambda_5_14 f = __lambda_5_14{num_1};
  return f.operator()(0);
}
```

When using coroutine lambdas (e.g. using seastar's `future`), the translation is the same:

```cpp
[]() -> seastar::future<> {
  // ...
};

class lambda {
 public:
  inline /*constexpr */ seastar::future<> operator()() const
  {
    // ...
  }
};
```

[Coroutine](https://en.cppreference.com/w/cpp/language/coroutines), introduced in C++20, also has its conversion rules. A special `promise` type defines the behavior of the coroutine, see [notes](https://github.com/JasonYuchen/notes/blob/master/coroutine/Cppcoro_Understanding_Promise.md#c-coroutines-understanding-the-promise-type).

> The Promise type is determined by the compiler from the return type of the coroutine using `std::coroutine_traits.`
> ...
> `std::coroutine_traits<R, ClassT /*cv-qual*/&, Args...>::promise_type`, if the coroutine is defined as a **non-static member function** that is not rvalue-reference-qualified

According to the above specification, when we are using coroutine lambdas, we are actually calling the anonymous class's overloaded `operator()` with lambda itself ([implicit object parameter](https://en.cppreference.com/w/cpp/language/member_functions#ref-qualified_member_functions)) being a cv-qualified reference. For simplicity we can assume the following conversion is applied to the coroutine lambda:

```cpp
seastar::future<> lambda::operator()(arguments) const;
// ->
seastar::future<> lambda_call_operator(const lambda& self, arguments); 
```

**The lambda itself is passed as cv-qualified reference into the coroutine function, and [reference parameters](https://github.com/JasonYuchen/notes/blob/master/coroutine/Cppcoro_Reference_Parameters.md) are not copied to the coroutine frame**, which is yet another essential part in coroutine usage.

We must guarantee that the lambda object is valid when we accessing its captures in the coroutine even the lambda object is not copied to the coroutine frame.

## The Pitfall

Back to the `use-after-free` [example](#a-weird-use-after-free), let's dive a little deeper into the seastar framework:

1. The lambda coroutine `func` is forwarded into the `.then()` and wrapped by a new lambda function

    ```cpp
    // seastar/core/shared_mutext.hh
    with_lock(shared_mutex& sm, Func&& func) noexcept {
        return sm.lock().then([&sm, func = std::forward<Func>(func)] () mutable {
            return futurize_invoke(func).finally([&sm] {
                sm.unlock();
            });
        });
    }
    ```

2. `then_impl_nrvo` is used to call `schedule` with forwarded `func` (skip some intermediate procedures)

    ```cpp
    // seastar/core/future.hh
    template <typename Func, typename Result>
    Result then_impl_nrvo(Func&& func) noexcept {
        using futurator = futurize<internal::future_result_t<Func, T SEASTAR_ELLIPSIS>>;
        typename futurator::type fut(future_for_get_promise_marker{});
        using pr_type = decltype(fut.get_promise());
        schedule(fut.get_promise(), std::move(func), [](pr_type&& pr, Func& func, future_state&& state) {
            if (state.failed()) {
                pr.set_exception(static_cast<future_state_base&&>(std::move(state)));
            } else {
                futurator::satisfy_with_result_of(std::move(pr), [&func, &state] {
                    return internal::future_invoke(func, std::move(state).get_value());
                });
            }
        });
        return fut;
    }
    ```

3. **A continuation is allocated** to store the `func` and above `wrapper`, which will be freed when the `func` is actually invoked in `run_and_dispose`

    ```cpp
    template <typename Pr, typename Func, typename Wrapper>
    void schedule(Pr&& pr, Func&& func, Wrapper&& wrapper) noexcept {
        // If this new throws a std::bad_alloc there is nothing that
        // can be done about it. The corresponding future is not ready
        // and we cannot break the chain. Since this function is
        // noexcept, it will call std::terminate if new throws.
        memory::scoped_critical_alloc_section _;
        auto tws = new continuation<Pr, Func, Wrapper, T SEASTAR_ELLIPSIS>(std::move(pr), std::move(func), std::move(wrapper));
        schedule(tws);
        _state._u.st = future_state_base::state::invalid;
    }

    // Func is the original function passed to then/then_wrapped. The
    // Wrapper is a helper function that implements the specific logic
    // needed by then/then_wrapped. We call the wrapper passing it the
    // original function, promise and state.
    virtual void continuation::run_and_dispose() noexcept override {
        try {
            _wrapper(std::move(this->_pr), _func, std::move(this->_state));
        } catch (...) {
            this->_pr.set_to_current_exception();
        }
        delete this;
    }
    ```

4. Put everything together:
   - Recall that the lambda coroutine is converted to a free function in which the **lambda itself is passed as cv-qualified reference**, i.e. `seastar::future<> lambda_call_operator(const lambda& self, arguments);`
   - The coroutine may **returns/suspends when it meets a [suspension point](https://github.com/JasonYuchen/notes/blob/master/coroutine/Cppcoro_Understanding_co_await.md#awaiters-and-awaitables-explaining-operator-co_await)**, those parameteres captured by value are copied into the coroutine frame, but those **captured by reference are not copied**, i.e. `const lambda& self` are not preserved in coroutine frame.
   - Since the control is returned to the caller, `wrapper` are freed in `run_and_dispose`, **lambda captures are also released**, however the coroutine may not complete and may **touch the lambda captures again** (e.g. [the example above](#a-weird-use-after-free))
   - oooooops, `use-after-free` occurs

## Solutions

1. Use [new API (not merged yet)](https://groups.google.com/g/seastar-dev/c/RFGF_a81lG4) and rely on [temporary lifetime extension rules](https://en.cppreference.com/w/cpp/language/lifetime) (this approach also has its own limitations)
2. **Prefer all-or-nothing approach to coroutines**, avoid using lambda coroutines in old continuation style APIs (safe and easy)
3. When you really have to use lambda coroutines with continuation APIs, make sure lambda coroutines are valid (need to be careful)
   - use `coroutine::lambda` to avoid deletion of the lambda itself
   - use `do_with` to protect the lambda
