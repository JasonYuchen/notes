# Lecture 20. Database Logging

## 错误分类 Failure Classification

1. **事务错误 Transaction Failures**
   - 逻辑错误：事务由于一些内部状态异常导致无法完成，例如违反了一致性约束
   - 内部状态错误：事务由于死锁等原因必须被主动终止
2. **系统错误 System Failures**
   - 软件错误：OS或DBMS实现的问题，例如除零异常
   - 硬件错误：运行DBMS的硬件设施故障，例如掉电；**故障停机Fail-Stop**假设认为非易失性存储non-volatile在系统停机后数据不会被破坏
3. **存储媒介错误 Storage Media Failures**
   - 不可修复硬件故障：磁盘故障、比特位跳变等不可修复的问题，通常系统会通过校验和等方式来检测（但不能修复）此类故障，没有数据库能从这种错误中恢复而只能在良好硬件上从归档数据恢复

由于易失性存储如内存的速度显著快于非易失性存储如磁盘，因此大多DBMS都会采用缓存策略，在内存中修改数据，随后写回磁盘，此时DBMS必须保证**已提交事务的修改一定持久化**而不会因为宕机等原因丢失，并且**终止事务的修改不会出现部分修改已经被持久化**

DBMS通过**回滚日志UNDO**和**重做日志REDO**来保证这两点，UNDO用于撤回终止日志的部分修改，REDO用于保证提交事务的所有修改

## 缓存池策略 Buffer Pool Policies

1. **STEAL**
   **DBMS是否允许未提交的事务覆盖磁盘中已提交事务的值**？STEAL代表允许，NO-STEAL代表不允许
2. **FORCE**
   **DBMS是否要求必须在事务提交前就将所有修改写入到非易失存储上**？FORCE代表要求，NO-FORCE代表不要求

很显然NO-STEAL组合FORCE的方式实现最为简单，此时不需要UNDO来回滚被覆盖的值也不需要REDO来重做提交但未写入的值，但这种方式性能非常差并且受制于内存的限制；而**STEAL组合NO-FORCE的方式**可以达到性能的最大化但需要UNDO和REDO配合，几乎所有DBMS都按此实现

## 影子分页 Shadow Paging

影子分页技术通过维护数据库数据的两份独立拷贝来实现上述要求：

- 主拷贝 Master：只保存所有已提交事务的数据
- 副拷贝 Shadow：包含各种未提交事务的修改

所有事务都只修改副拷贝，等到事务提交时，原子的将副拷贝变为主拷贝，此时缓存池的策略就是**NO-STEAL+FORCE**

![20.1](images/20.1.png)
![20.2](images/20.2.png)

采用影子分页技术：

- **日志的需求**：
  - UNDO：只需要做移除Shadow pages的任务，只保留master和DB root pointer
  - REDO：不需要
- **缺点**：
  - 需要拷贝整个页表，开销非常大，可以通过使用类似B+树的页表目录结果来优化，此时不需要拷贝整个树，只需要拷贝更新叶节点的路径对应的页表即可
  - 提交的开销非常大，需要刷新每一个脏页、页表、根节点，数据碎片化因此额外需要垃圾回收
  - 写入磁盘时DBMS需要做很多随机写入（不同页表分散在磁盘上）性能代价很大

## 预写式日志 Write-Ahead Log

## 日志模式 Logging Schemes

## 检查点 Checkpoints
