# Lecture 14. Query Planning I

## 查询优化 Query Optimization

- **启发式 Heuristics/Rules**：重写查询来避免低效的操作，通常需要检查系统数据catalog，但不需要检查真实数据data
- **基于代价式 Cost-based Search**：基于统计数据（表的总行数、算子的复杂度等）等衡量一个计划的代价，通过对比多个不同计划的代价来选择一个最优执行方案

![14.1](images/14.1.png)

优化器optimizer会生成一个逻辑计划logical algebra expression到最优等价物理计划physical algebra expression，而物理算子就会决定数据的实际处理方式（通常与数据存储格式、压缩、排序等有关）

**查询优化是NP-Hard问题**，现在有大量采用机器学习进行优化的方案

## 等价关系代数 Relational Algebra Equivalences

两个关系代数表达式只要产生相同的结果，就可以认为这两个关系代数表达式是等价的，DBMS通过等价关系代数进行**查询重写query rewriting**来优化查询

- **Selections**
  在查询中，谓词等应被尽早执行来减少后续处理的数据量，例如在下列查询中，**谓词下推 Predicate Pushdown**就可以将谓词`WHERE`下推到每个表，从而减少连接时的数据量

    ```SQL
    SELECT s.name, e.cid
      FROM student AS s, enrolled AS e
      WHERE s.sid = e.sid AND e.grade = 'A'
    ```

  ![14.2](images/14.2.png)
- **Joins**
  利用交换性Commutative和结合性Associative可以对多个连接的顺序进行调整，来最小化数据的处理量
- **Projections**
  尽早执行投影以减少中间结果的空间占用（避免不需要用到的属性占用额外空间），显然对于天然只会用到所需属性的OLAP，这种优化是自动完成的，例如在下列查询种，**投影下推 Projection Pushdown**就可以将`SELECT`下推到每个表，从而中间结果的数据占用空间可以显著减少

    ```SQL
    SELECT s.name, e.cid
      FROM student AS s, enrolled AS e
      WHERE s.sid = e.sid AND e.grade = 'A'
    ```
  
  ![14.3](images/14.3.png)

## 逻辑查询优化 Logical Query Optimization

`TODO`

## 嵌套查询 Nested Queries

`TODO`

## 表达式重写 Expression Rewriting

`TODO`
