# Lecture 19. Peer-to-Peer: Bitcoin

阅读材料笔记[Bitcoin](Bitcoin.md)

## 签名的事务

传统交易方式基于信任，需要引入受信的第三方，而加密货币可以实现**不基于信任而是基于密码学的可靠交易**

事务流程如下图，详细说明[见此](Bitcoin.md#事务-Transactions)

![BTC1](images/BTC1.png)

```text
Y owns a coin, previously given to it by X:
  T6: pub(X), ...
  T7: pub(Y), hash(T6), sig(X)
Y buys a hamburger from Z and pays with this coin
  Z sends public key to Y
  Y creates a new transaction and signs it
  T8: pub(Z), hash(T7), sig(Y)
Y sends transaction record to Z
Z verifies:
  T8's sig(Y) corresponds to T7's pub(Y)
Z gives hamburger to Y
```

实际上只有事务真实存在，而币并不存在，每个账户的**余额balance是一组未支付的事务**，并且只有该账户所有者持有这些事务的私钥，每个币的**身份identity是该币最近的一次事务的散列值**

存在**双重支付风险double-spend**，由于只有payer的签名，若被多重支付，多个payees只能通过公钥确认payer的身份，无法确认payer是否发起了多笔交易

## 公开所有事务

如果**每一笔交易都被公开**，则所有payee都能检查前序所有交易从而确认不会有双重支付，通过去中心化的方式公布所有交易，这种public log也叫**public ledger**

假如采用传统的方式达成majority共识来确认交易，则vote对应的单位不可以是主机、IP等容易伪造的标识（容易被攻击者伪造出majority从而控制比特币网络），**比特币采用了每单位CPU算力对应一个vote**

## 比特币区块链 the BitCoin block chain

### 基本设计

- 每个节点（全节点）都保存整个链完整的一份副本
- 每个节点通过TCP与少数几个节点连接——**"mesh overlay"**
- 每个节点收到新区块时都通过推送给连接的节点，最终全网络接受（类似gossip）
- 每个发生的事务也被推送给全网络从而被包含在下一个区块中

### 事务的确认

1. 每个节点已经持有`...<-B5`链，并且都在通过Proof-of-Work尝试计算出`B6`块（B6块已包含足够事务，**"挖矿"计算指不断修改nonce**）
2. Y发起一笔交易`Y->Z`，并将该交易推送给全网络
3. 每个节点**收到`Y->Z`就缓存下来准备放入后续的`B7`块**
4. 某个节点计算出`B6`块，并推送给全网络达成共识，从而`...<-B5<-B6`
5. 最终链变成`...<-B5<-B6<-B7`，Z从链中**发现了`B7`块，并确认了`Y->Z`事务**，从而事务确认完成

存在出现两个节点几乎同时计算出`B6`块的可能，此时会**暂时出现分支fork**，部分节点首先收到`B6`并基于该块继续计算（但是缓存后收到的`B6'`），而部分节点收到`B6'`并基于该块继续计算（缓存`B6`），但是**最终所有节点都会在发现更长链时，抛弃缓存的锻链**

```text
[B5]<-[B6]<-[B7']... some work on this chain
   fork: \<-[B7'']... some work on this chain

[B5]<-[B6]<-[B7']<-[B8]... work on this chain once seen
         \<-[B7''] abandoned since longer chain found
```

大部分情况下，一个事务会同时出现在两个分支的区块中，因此无论哪个分支成为最长链都不影响，但是**有概率出现一个事务先出现在区块中，随后因为链较短被放弃又消失**

### 双重支付

- 假如恶意节点Y**同时发出两次支付`Y->Z`和`Y->Q`**
  正确的节点会接受第一次支付而忽略第二次支付，因此下一个块只会包含其中一个结果
- 假如恶意节点Y**向一部分节点发出`Y->Z`而向另一部分节点发出`Y->Q`**
  由于事务的确认可能出现暂时的分支，因此存在一定可能性在一个分支上存在`Y->Z`而在另一个分支存在`Y->Q`，但最终网络只会接受更长的链，其中一次支付记录就会消失，因此假如某一次支付涉及**大量数额，等待比特币网络多增加几个区块**可以直接将双重支付可能性降到接近0
- 假如攻击者**占据了一般以上的计算力**
  从而可以从中间某个区块**直接fork新链，并且通过计算力最终使得新链超过原链**，从而可以实现双重支付，但是激励incentive鼓励拥有大算力的继续作为诚信节点产出新的区块而不是fork，且占据一半算力的难度极大

### 验证

- **对新的事务**
  - 校验此前没有相同的支付，即验证没有双重支付
- **对新的区块**
  - 通过nonce校验散列值有足够的前缀0，从而保证区块有效
  - 前缀区块的散列值有效
  - 区块中的所有事务有效
  - 若链更长则切换到更长的链
- **支付的接收者payee**
  - 验证`payer->payee`事务存在于新的区块中
  - payee's public key/address存在于该事务中
  - 该区块后缀已经有了其他区块（减少double-spend可能性）

### 占据一半算力？

- 通过forking可以**双重支付、不支付**
- **无法偷取**别人的比特币
- 可以**禁止一些事务**参与确认（不放入新的区块）

### 一些细节问题

- **为什么十分钟一个产生区块？**
  由于比特币网络**需要一定时间来让区块抵达大多数节点**，并且所有节点只认可最长的链
  
  假如时间间隔非常短（例如和广播新区块达成共识的延迟可比）则一旦一个节点计算出新区块就会立即开始计算下一块，其和其周围的节点有更大的可能较快算出下一个块
  
  其他**晚收到新区块的节点则经常在做无用功**（在计算新区块，但是事实上远端节点已经有了更长链只是还未发送到此）从而打击网络参与者的积极性

  因此通常新区块推广到整个网络的延迟应该远小于挖出新区块的时间，从而**近似认为所有节点都在同一起跑线上计算下一个区块**
- **比特币网络会根据当前算力调整计算出nonce的难度，如何让所有节点对难度达成共识？**
  由于每个节点都只认可最长链，从而可以认为每个节点事实上都基于最长区块链做判断，从而可以通过定义一个**基于最长链的确定性deterministic函数，来返回nonce的难度**，那么所有节点都可以通过该函数，和共同的最长链来获得相同的nonce达成共识

  比特币网络实际上**根据每个区块的时间戳timestamp**来确定新块的产生速度进而确定计算下一块的难度

### 缺点

- 作为加密货币，确认时间过长（往往需要10-60分钟确认一笔交易）
- PoW浪费计算力
- 无法避免majority攻击
- 并不是非常匿名（例如多笔交易指向同一个public key，也可以通过每一次交易都使用新的一对public/private key加强）
- 部分场景下过于匿名容易引起犯罪可能
- 用户需要妥善保存private key
